
/*
** WCS_locale.c
**
** (c) 2011 by Guido Mersmann
**
** Object source created by SimpleCat.
**
** DO NOT EDIT THIS FILE UNLESS YOU KNOW WHAT YOU ARE DOING
**
** Usage is quite simple.
**
** 1. Add this file to object creation list in makefile.
**
** 2. Call Locale_Open() and Locale_Close() on startup and shut down of your code.
**    There is no need to check any result.
**
** 3. Make sure the marked include line within 'WCS_locale.h' header file uses
**    the name of your string header file. Thats name in .CS file which is set with
**    TARGET C header file command or when using the GUI in target list. By default
**    its "locale_strings.h". Make sure you use the following switches for the C
**    target to create a valid header file for this code:
**    NoCode NoArray NoBlockStatic
**
** 4. Include the 'WCS_locale.h' header everywhere you need a locale string.
**
** 5. Call GetString( id ) where ever you need a locale string. "id" is the label name
**    you address the strings. To follow the style guide you should name the files
**    using "MSG_" prefix.
**
** 6. Thats all!
**
*/

#include <ctype.h>
#include <exec/types.h>
#include <libraries/locale.h>

#include <proto/locale.h>
#include <proto/exec.h>

#define CATCOMP_BLOCK 1     /* enable CATCOMP_BLOCK */
#include "WCS_locale.h" /* prototypes and catcomp block */

#include "BigEndianReadWrite.h"
/*************************************************************************/

#ifdef __amigaos4__
struct Library     *LocaleBase;
struct LocaleIFace *ILocale;
#else
struct LocaleBase  *LocaleBase;
#endif

// debug output in WCS.c, therefore not static
/*static*/ struct Locale      *locale_locale;
/*static*/ struct Catalog     *locale_catalog;

/*************************************************************************/

/* /// Locale_Open */

/*************************************************************************/

BOOL Locale_Open( STRPTR catname, ULONG version/*, ULONG revision*/)
{
	if( (LocaleBase = (APTR) OpenLibrary( "locale.library",0 )) ) {
#ifdef __amigaos4__
		if( (ILocale = (struct LocaleIFace *) GetInterface( LocaleBase, "main", 1, NULL)) ) {
#endif
			if( (locale_locale = OpenLocale(NULL)) ) {
				if( (locale_catalog = OpenCatalogA(locale_locale, catname, TAG_DONE)) ) {
					if(       locale_catalog->cat_Version  == version
//						   && locale_catalog->cat_Revision == revision   // look only for exact version, not for exact revision
						   )
					{
	                    return(TRUE);

	                }
					CloseCatalog(locale_catalog);
					locale_catalog = NULL;
	            }
	            CloseLocale(locale_locale);
	            locale_locale = NULL;
			}
#ifdef __amigaos4__
			DropInterface((struct Interface *)ILocale);
        }
#endif
		CloseLibrary( (APTR) LocaleBase );
		LocaleBase = NULL;
    }
	return(FALSE);
}
/* \\\ Locale_Open */

/* /// Locale_Close */

/*************************************************************************/

void Locale_Close(void)
{
    if( LocaleBase) {
        if( locale_catalog) {
            CloseCatalog(locale_catalog);
            locale_catalog = NULL;
        }
        if( locale_locale) {
            CloseLocale(locale_locale);
            locale_locale = NULL;
        }
#ifdef __amigaos4__
		DropInterface((struct Interface *)ILocale);
#endif
		CloseLibrary( (APTR) LocaleBase );
		LocaleBase = NULL;
    }
}
/* \\\ */

/* /// GetString */

/*************************************************************************/
// Check is strng is NULL or contains only white spaces
static int is_empty_or_whitespace(const char *str) {
  if (str == NULL) {
    return TRUE;
  }

  while (*str) {
    if (!isspace(*str)) {
      return FALSE;
    }
    str++;
  }
  return TRUE;
}

#ifdef GetString_ORG
STRPTR GetString(long id)
{
LONG   *l;
LONG    l_content;
UWORD  *w;
UWORD   w_content;
STRPTR  builtin;

	l = (LONG *)CatCompBlock;

//       +---+---+---+----------------  id
//       |   |   |   |   +---+--------  offset to next id
//       |   |   |   |   |   |
//    "\x00\x00\x00\x00\x00\x08"
//    Project "\x00"                  //MSG_MENU_PROJECT_STR
//
//    "\x00\x00\x00\x01\x00\x08"
//	  New... "\x00\x00"               // MSG_MENU_PR_NEW_STR
//
//    "\x00\x00\x00\x02\x00\x08"
//    Edit... "\x00"                  // MSG_MENU_PR_EDIT_STR
//
//    "\x00\x00\x00\x03\x00\x08"
//    Open... "\x00"                  // MSG_MENU_PR_OPEN_STR
//
//    "\x00\x00\x00\x04\x00\x06"
//    Save "\x00\x00"                 // MSG_MENU_PR_SAVE_STR
//
//    "\x00\x00\x00\x05\x00\x0C"
//    Save As... "\x00\x00"           // MSG_MENU_PR_SAVEAS_STR

	l_content=*l;
	ENDIAN_CHANGE_IF_NEEDED(SimpleEndianFlip32S(l_content,&l_content);)

    while (l_content != id ) {
        w = (UWORD *)((ULONG)l + 4);

        w_content=*w;
        ENDIAN_CHANGE_IF_NEEDED(SimpleEndianFlip16U(w_content,&w_content);) // AF: 2.Jul.2024, Endian correction for i386-aros

        l = (LONG *)((ULONG)l + (ULONG)w_content + 6);   // next: 4 bytes id-value + 2 bytes offset-value + 0 bytes string
        l_content=*l;
        ENDIAN_CHANGE_IF_NEEDED(SimpleEndianFlip32S(l_content,&l_content);)
    }
    builtin = (STRPTR)((ULONG)l + 6);

    if ( locale_catalog && LocaleBase ) {
    	APTR string=GetCatalogStr( locale_catalog, id, builtin);
    	if(!is_empty_or_whitespace(string))   // AF: if translated string is not empty, return it
    	{
    		return string;
    	}
    }
    return(builtin);  // AF: if string is empty, return builtin
}
/* \\\ GetString */
#else

STRPTR GetString(long id)
{
    LONG   *l;
    LONG    l_content;
    UWORD  *w;
    UWORD   w_content;
    STRPTR  builtin;

    // Annahme: Drei Teile des CatCompBlocks, die mit ihren Endadressen bekannt sind
    LONG *l_part1 = (LONG *)CatCompBlockPart1;
    LONG *l_part2 = (LONG *)CatCompBlockPart2;
    LONG *l_part3 = (LONG *)CatCompBlockPart3;

    // Groessen der drei Teile des Blocks (muessen bekannt sein oder berechnet werden)
    LONG *end_part1 = (LONG *)((ULONG)l_part1 + sizeof(CatCompBlockPart1));
    LONG *end_part2 = (LONG *)((ULONG)l_part2 + sizeof(CatCompBlockPart2));
    LONG *end_part3 = (LONG *)((ULONG)l_part3 + sizeof(CatCompBlockPart3));

    static int Init=TRUE;
    if(Init)
    {
    	Init=FALSE;
//    	printf("ALEXANDER: sizeof(CatCompBlockPart1)=%d\n",sizeof(CatCompBlockPart1));
//    	printf("ALEXANDER: sizeof(CatCompBlockPart2)=%d\n",sizeof(CatCompBlockPart2));
//    	printf("ALEXANDER: sizeof(CatCompBlockPart3)=%d\n",sizeof(CatCompBlockPart3));
    }


    // Zuerst den ersten Block durchsuchen
    l = l_part1;
    l_content = *l;
    ENDIAN_CHANGE_IF_NEEDED(SimpleEndianFlip32S(l_content, &l_content);)

    // Suche im ersten Block
    while (l_content != id) {
        // Wenn das Ende des ersten Blocks erreicht ist, wechseln wir zum zweiten Block
        if (l >= end_part1) {
            l = l_part2; // Wechsel zu Part2
            l_content = *l;
            ENDIAN_CHANGE_IF_NEEDED(SimpleEndianFlip32S(l_content, &l_content);)
            break; // Break, um die weitere Suche im zweiten Block fortzusetzen
        }

        w = (UWORD *)((ULONG)l + 4);
        w_content = *w;
        ENDIAN_CHANGE_IF_NEEDED(SimpleEndianFlip16U(w_content, &w_content);)

        l = (LONG *)((ULONG)l + (ULONG)w_content + 6); // zum naechsten Eintrag
        l_content = *l;
        ENDIAN_CHANGE_IF_NEEDED(SimpleEndianFlip32S(l_content, &l_content);)
    }

    // Falls wir immer noch nicht die ID gefunden haben, weiter suchen im zweiten Block
    while (l_content != id) {
        // Sicherstellen, dass wir nicht ueber das Ende des zweiten Blocks hinauslesen
        if (l >= end_part2) {
            l = l_part3; // Wechsel zu Part3
            l_content = *l;
            ENDIAN_CHANGE_IF_NEEDED(SimpleEndianFlip32S(l_content, &l_content);)
            break; // Break, um die weitere Suche im dritten Block fortzusetzen
        }

        w = (UWORD *)((ULONG)l + 4);
        w_content = *w;
        ENDIAN_CHANGE_IF_NEEDED(SimpleEndianFlip16U(w_content, &w_content);)

        l = (LONG *)((ULONG)l + (ULONG)w_content + 6); // zum naechsten Eintrag
        l_content = *l;
        ENDIAN_CHANGE_IF_NEEDED(SimpleEndianFlip32S(l_content, &l_content);)
    }

    // Falls wir immer noch nicht die ID gefunden haben, weiter suchen im dritten Block
    while (l_content != id) {
        // Sicherstellen, dass wir nicht ueber das Ende des dritten Blocks hinauslesen
        if (l >= end_part3) {
            break; // Ende des dritten Blocks erreicht, keine weitere Suche
        }

        w = (UWORD *)((ULONG)l + 4);
        w_content = *w;
        ENDIAN_CHANGE_IF_NEEDED(SimpleEndianFlip16U(w_content, &w_content);)

        l = (LONG *)((ULONG)l + (ULONG)w_content + 6); // zum naechsten Eintrag
        l_content = *l;
        ENDIAN_CHANGE_IF_NEEDED(SimpleEndianFlip32S(l_content, &l_content);)
    }

    // Der String befindet sich nun an (l + 6), wie zuvor
    builtin = (STRPTR)((ULONG)l + 6);

    // Lokalisierte Version des Strings abrufen, falls verfuegbar
    if (locale_catalog && LocaleBase) {
        APTR string = GetCatalogStr(locale_catalog, id, builtin);
        if (!is_empty_or_whitespace(string)) {
            return string;
        }
    }

    return(builtin); // Rueckgabe des Standardstrings, falls nichts Uebersetztes gefunden wurde
}

#endif
